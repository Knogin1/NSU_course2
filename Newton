#include <iostream>
#include <vector>
#include <random>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <tuple>

// Используем std::pair для хранения точек
using Point = std::pair<double, double>;
using CircleParams = std::tuple<double, double, double>; // (x_center, y_center, radius)

// Генерация точек вокруг единичной окружности с небольшим отклонением
std::vector<Point> generatePoints(int num_points, double noise_std = 0.1) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<> noise_dist(0.0, noise_std);
    std::uniform_real_distribution<> angle_dist(0.0, 2 * M_PI);
    
    std::vector<Point> points;
    points.reserve(num_points);
    
    for (int i = 0; i < num_points; ++i) {
        double angle = angle_dist(gen);
        double radius = 1.0 + noise_dist(gen);
        
        double x = radius * cos(angle);
        double y = radius * sin(angle);
        
        points.emplace_back(x, y);
    }
    
    return points;
}

// Функция для вычисления среднеквадратичного отклонения
double computeLoss(const std::vector<Point>& points, double xc, double yc, double R) {
    double loss = 0.0;
    for (const auto& [x, y] : points) {
        double dx = x - xc;
        double dy = y - yc;
        double distance = std::sqrt(dx*dx + dy*dy);
        double diff = distance - R;
        loss += diff * diff;
    }
    return loss / points.size();
}

// Градиент функции потерь
std::tuple<double, double, double> computeGradient(
    const std::vector<Point>& points, 
    double xc, double yc, double R) {
    
    double grad_xc = 0.0;
    double grad_yc = 0.0;
    double grad_R = 0.0;
    size_t n = points.size();
    
    for (const auto& [x, y] : points) {
        double dx = x - xc;
        double dy = y - yc;
        double distance = std::sqrt(dx*dx + dy*dy);
        
        if (distance > 1e-10) {  // избегаем деления на ноль
            double factor = 2.0 * (distance - R) / distance;
            grad_xc += factor * dx;
            grad_yc += factor * dy;
        }
        grad_R += -2.0 * (distance - R);
    }
    
    return {grad_xc / n, grad_yc / n, grad_R / n};
}

// Метод Ньютона для оптимизации
CircleParams newtonMethod(const std::vector<Point>& points, 
                         double xc0, double yc0, double R0,
                         int max_iterations = 1000, 
                         double tolerance = 1e-8) {
    
    double xc = xc0;
    double yc = yc0;
    double R = R0;
    
    for (int iter = 0; iter < max_iterations; ++iter) {
        // Вычисляем градиент
        auto [grad_x, grad_y, grad_R] = computeGradient(points, xc, yc, R);
        
        // Простой шаг градиентного спуска (упрощенная версия метода Ньютона)
        // В полном методе Ньютона здесь должна быть матрица Гессе
        double learning_rate = 0.1;
        
        double xc_new = xc - learning_rate * grad_x;
        double yc_new = yc - learning_rate * grad_y;
        double R_new = R - learning_rate * grad_R;
        
        // Проверяем сходимость
        double dx = xc_new - xc;
        double dy = yc_new - yc;
        double dR = R_new - R;
        
        if (dx*dx + dy*dy + dR*dR < tolerance * tolerance) {
            break;
        }
        
        xc = xc_new;
        yc = yc_new;
        R = R_new;
        
        // Можно добавить вычисление и использование матрицы Гессе для настоящего метода Ньютона
        // но это требует вычисления вторых производных
    }
    
    return {xc, yc, R};
}

// Альтернативный метод: используем аналитическое решение для начального приближения
CircleParams fitCircleAnalytical(const std::vector<Point>& points) {
    size_t n = points.size();
    
    // Вычисляем среднее для использования в качестве начального центра
    double sum_x = 0.0, sum_y = 0.0;
    for (const auto& [x, y] : points) {
        sum_x += x;
        sum_y += y;
    }
    
    double xc0 = sum_x / n;
    double yc0 = sum_y / n;
    
    // Вычисляем средний радиус как начальное приближение
    double sum_r = 0.0;
    for (const auto& [x, y] : points) {
        double dx = x - xc0;
        double dy = y - yc0;
        sum_r += std::sqrt(dx*dx + dy*dy);
    }
    double R0 = sum_r / n;
    
    return newtonMethod(points, xc0, yc0, R0);
}

// Метод наименьших квадратов для более точного начального приближения
CircleParams fitCircleLeastSquares(const std::vector<Point>& points) {
    size_t n = points.size();
    
    double sum_x = 0.0, sum_y = 0.0;
    double sum_x2 = 0.0, sum_y2 = 0.0, sum_xy = 0.0;
    double sum_x3 = 0.0, sum_y3 = 0.0, sum_x2y = 0.0, sum_xy2 = 0.0;
    
    for (const auto& [x, y] : points) {
        double x2 = x * x;
        double y2 = y * y;
        double xy = x * y;
        
        sum_x += x;
        sum_y += y;
        sum_x2 += x2;
        sum_y2 += y2;
        sum_xy += xy;
        sum_x3 += x2 * x;
        sum_y3 += y2 * y;
        sum_x2y += x2 * y;
        sum_xy2 += x * y2;
    }
    
    double C = n * sum_x2 - sum_x * sum_x;
    double D = n * sum_xy - sum_x * sum_y;
    double E = n * sum_x3 + n * sum_xy2 - (sum_x2 + sum_y2) * sum_x;
    double G = n * sum_y2 - sum_y * sum_y;
    double H = n * sum_x2y + n * sum_y3 - (sum_x2 + sum_y2) * sum_y;
    
    double denominator = 2 * (C * G - D * D);
    if (std::abs(denominator) < 1e-10) {
        return fitCircleAnalytical(points);
    }
    
    double xc = (E * G - D * H) / denominator;
    double yc = (C * H - D * E) / denominator;
    
    // Вычисляем радиус
    double sum_r2 = 0.0;
    for (const auto& [x, y] : points) {
        double dx = x - xc;
        double dy = y - yc;
        sum_r2 += dx*dx + dy*dy;
    }
    double R = std::sqrt(sum_r2 / n);
    
    return {xc, yc, R};
}

int main() {
    // Генерация точек
    int num_points = 100;
    auto points = generatePoints(num_points, 0.1);
    
    std::cout << "Сгенерировано " << points.size() << " точек\n";
    
    // Метод 1: Аналитическое начальное приближение + оптимизация
    auto [xc1, yc1, R1] = fitCircleAnalytical(points);
    double loss1 = computeLoss(points, xc1, yc1, R1);
    
    std::cout << "\nМетод 1 (аналитический + оптимизация):\n";
    std::cout << "Центр: (" << xc1 << ", " << yc1 << ")\n";
    std::cout << "Радиус: " << R1 << "\n";
    std::cout << "Среднеквадратичное отклонение: " << loss1 << "\n";
    
    // Метод 2: Метод наименьших квадратов + оптимизация
    auto [xc2, yc2, R2] = fitCircleLeastSquares(points);
    double loss2 = computeLoss(points, xc2, yc2, R2);
    
    std::cout << "\nМетод 2 (наименьшие квадраты + оптимизация):\n";
    std::cout << "Центр: (" << xc2 << ", " << yc2 << ")\n";
    std::cout << "Радиус: " << R2 << "\n";
    std::cout << "Среднеквадратичное отклонение: " << loss2 << "\n";
    
    // Выводим некоторые точки для проверки
    std::cout << "\nПервые 5 точек:\n";
    for (int i = 0; i < 5 && i < points.size(); ++i) {
        std::cout << "(" << points[i].first << ", " << points[i].second << ")\n";
    }
    
    return 0;
}
